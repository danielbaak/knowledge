= Bash Summary


== Structure of a bash program


Bash scrips basically are composed of Lists, which are composed of
Pipes, which are composed of Commands, which are composed of Words. The
first word of a command is the command name, the following words are the
arguments passed to the command. (Standart-)input and (standart-) output
of commands can be redirected using pipes and redirections.

Commands are callable/executable code. E.g. executable files on the file
system, or builtins of bash, or bash script functions.

The lists, i.e. at the the end commands, are executed as they appear in
the script.

To lessen redundant code, one can define functions and call them like
regular commands.

== Lists, Pipes, Commands

=== Commands

See +Command+ in bash.yas

1) Manual says redirections are part of a simple command. I think
they are really part of a command. For simple commands, redirections can
appear distributed anywhere between distinctict words of the simple
command. For compound commands, they can only appear at the end. ??? I
don't know what the rules are if redirections/pipe contradict/conflict,
e.g. if stdout is redirected to two different things, or if a file is
written two by two diffrent fd's.

The return status of a simple command is its exit status as provided by the
POSIX 1003.1 `waitpid' function, or 128+N if the command was terminated by
signal N.


=== Pipes

See +Pipe+ in bash.yas

A pipe combines commands; the std output of the right command of a pipe
operator \verb#|# is redirected to the std input of the left comand.

Each command in a pipeline is executed in its own subshell. The exit
status of a pipeline is the exit status of the last command in the
pipeline (this can be altered by pipefail option). If the keyword
\verb|!| precedes the pipe, the exit status is logically inverted.

The shell waits for all commands in the pipeline to terminate before
returning a value.

The keyword \verb|time| causes timing statistics to be printed; the option -p
changes the ouptut format to that specified by POSIX.

// ??? Why is \verb|time;| valid but neither of ";" "! ;"??? Either an empty
// command is allowed or not.

// ??? Why doesnt this work \verb|time && time| This at least works
// \verb|time echo && time echo|.

=== Lists

See +List+ in bash.yas

A list combines pipes.

And combination +&&+:: Right pipe is only executed if left pipe's exit status
is 1. Combined exit status is the result of a logical and operation on the exit
status of the two pipes.

Or combination +||+:: Right pipe is only executed if left pipe's exit status
is 0. Combined exit status is the result of a logical or operation on the exit
status of the two pipes.

Async sublist +&+:: Executes sublist asynchronously in a subshell, also known as
executing it in the background. See also job control how to figure out when it
finished and with what exit status.

Sync sublist +;+:: Executes the sublist synchronous to current shell.

The manual sometimes also uses command list as synonym for list.

// It is not 100\% clear to me where ; is optional and where not.
// UnaryListOp might be optional because for e.g. the last command in ( )
// or in { } does not have to have a terminator.

== Compound commands / flow control

=== Grouping / Compound

See +CompoundCommand+ in bash.yas.

Tests are true when the exit status is 0. The exit status of the whole
looping command is the exit status of the last command in the body, or 0
if no command was executed.

== Redirections

See also Command where redirections can appear. Redirections are processed from
left to right. See also exec built in for how to operate on file descriptors of
current shell, in contrast to subshell of command to be called.

......................................................................
Fd = '[0-9]+;
FdWord = Word;
FileName = Fd | Word;
......................................................................

The file descriptor +Fd+ must be given literally, it can not come from an
expanded parameter as in ++fd=1; mycmd $fd>out.txt;++. ++FdWord++ and
++Filename++ respectively on the other hand are expanded. If the expanded
++FdWord++ does not result in a filedescriptor open for input/output, a
redirection error occures.

If +Fd+ is not supplied it defaults to 0 (i.e. std input) for input redirections
and for <>. For output redirections it defaults to 1 (i.e. std out).


=== Redirecting input
Aka open filedescriptor for input

..................................................
[Fd] < Filename
..................................................

translated to pseudo code

..................................................
FdList[fd].open( read, filename )
..................................................

=== Redirecting output
Aka open filedescriptor for output

..................................................
[Fd] >  Filename
[Fd] >| Filename
[Fd] >> Filename
..................................................

translated to pseudo code

..................................................
>   FdList[fd].open( write | create, filename ) // fails if file exist and noclobber
>|  FdList[fd].open( write | create, filename ) // always creates new file
>>  FdList[fd].open( write | append, filename )
..................................................

=== Open file descriptor for input 'and' output
..................................................
[Fd] <> Filename
..................................................

translated to pseudo code

..................................................
FdList[fd].open( read | write | create, filename ) 
..................................................

=== Close file descriptor
..................................................
[Fd] <-
[Fd] >-
..................................................

translated to pseudo code

..................................................
FdList[fd].close()
..................................................
+<+ must be used if fd is open for input, wheras +>+ must be used if fd is open
for output. If done wrongly, an error occurs.


=== Duplicate/move file descriptor
..................................................
[Fd] <& FdWord[-]
[Fd] >& FdWord[-]
..................................................

translated to pseudo code

..................................................
FdList[fd] = FdList[FdWord];
if ( - is supplied )
  FdList[FdWord].close(); 	
..................................................

An error occures if < is used and FdWord is not open for input. Analogous for >
and beeing open for output.

=== Here documents

..................................................
## Here string. Word is expanded and supplied as input
[Fd] `<<< Word | 
      
## Here documents. The text upto a line containing *only* the delimiter
## is supplied as input.
## No expansion is done on word following <<[-]
$simple
[Fd] "<<"[\-] Word#Del ... #Del     
      
$medium      
[Fd] "<<"[\-] @Del(Word) ... \n ## rest of cmd upto 1st unqoted \n
  ...        ## here document, incl trailing newline
  @>Del\n;   ## line containing only delimiter  

[Fd] << [-] Delimiter 	
..................................................

After the list(?) any sequence of characters form the input, until a line which
ONLY contains delimiter. Details: Delimiter can be any word. No parameter
expansion, command substitution, arithmetic expansion, or filename expansion is
performed on Delimiter. If any characters in WORD are quoted, the DELIMITER is
the result of quote removal on WORD, and the lines in the here-document are not
expanded. If Delimiter is unquoted, all lines of the here-document are subjected
to parameter expansion, command substitution, and arithmetic expansion. If the
redirection operator is ``<<-'', then all leading tab characters (only tab, no
other white spaces) are stripped from input lines and the line containing
DELIMITER. This allows here-documents within shell scripts to be indented in a
natural fashion.

Multiple here docments in a list are possible. See help for quoting/expansion
rules for Delimiter and suplied input.


== Command line processing

// ??? When is it splitt into lists/pipes/compound commands/commands ?


1. Tokenize
- Split into tokens, i.e. words and operators. Exp in Arithmetic expression
  behaves as in double quotes, but a double quote within is not treaded
  specially.
- If first token is a) an opening keyword, read next command and goto tokenize
  b) an alias, expand alias and goto tokenize c) another keyword, its a syntax
  error.
  
2. Each so resulting word undergoes then
-  Brace expansion
  
3. Each so resulting word undergoes then
- Tilde expansion.
- Parameter expansion. DQ, 1)
- Command substitution. DQ
- Arithmetic substitution. DQ
  
- Process substituion. 
- Word splitting. NW
- Pathname expansion. NW
- Quote removal 
  
4. Command lookup. First word is the command name, the following words are
arguments. If command name is +eval+, concatenate arguments into a single string
and goto tokenize. Else setup environment and run command.

.Legend and Footnotes
DQ:: Also within double quotes
NW:: Can change the number of words. That has effect on the following steps.
1):: +$@+ and +${NAME[@]}+ can change number of words


// # the words resulting from brace expansion are eligble for the rest of the
// # expansions.
// $ echo ~{flo,edi} 
// /home/flo /home/edi
// $ xpostfix=1; ypostfix=2;
// $ echo {$x,$y}postfix
// 1 2

// # Expansions (except brace- and filename-) do not change number of words. 
// # It's word splitting who does that.
// $ echo flo_text > flo; echo edi_text > edi
// $ cat $(ls edi flo)
// edi_text
// flo_text
// $ IFS=""; cat $(ls edi flo)
// cat: edi
// flo: No such file or directory


// TODO: Add to table where whites are removed (e.g. command subst, proc subst)  

== Expansions

=== Brace expansion

..................................................
BraceExpansion = [Preamble]\{(Seq|(EltStr\,{~}){2,})\}[Postscript];
  Seq = Num".."Num | Char".."Char;
  Num = ['[+-]]'[0-9]+;
  Char = \a;
  Str = %simple \a* %exact ('[^\\,}]*[\\'[\\,}\s]])*;
Word <=| BraceExpansion;   
## The given word is replaced by the resulting space separated list
..................................................     

- The string "++${++" is not eligble for the start of brace expansion
- A literal +{+ , +\+ or space must be quoted with +\+   
- ++echo {a,b}$PATH++ becomes ++echo a$PATH b$PATH++ which in turn is expanded later   
- ++echo $x{a,b}++ becomes ++echo $xa $xb++, whereas ++$xa++ and ++$xb++ are
  probably not defined
- ++{0,1}{0,1}... ++is like ++{0,1}({0,1}(...))++, i.e. the left is the preamble
  of the following.

=== Tilde Expansion
..................................................
TildeExpansion = \~(TildePrefix)[\/[WordTail]];
  
TildePrefix =
  `+  | ## PWD
  `-  | ## OLDPWD (actually ${OLDPWD-'~-'})
  Num | ## directory stack elt, i.e. output of 'dirs Num'
  UserName; 
UserName =
  ""  |  ## HOME
  %simple
  Word   ## home dir associated with that username
  %exact
  ^(Blank|'[\\/])+; ## ?? no idea if that is right

 Num = ['[+-]]'[0-9]+;
 
Word <=| TildeExpansion;               
..................................................
     
If anything fails, the word is left unchanged               


== Startup files

interactive login shell::
1. +/etc/profile+
2. First existing of
  - +~/.bash_profile+
	- +~/.bash_login+
	- +~/.profile+

interactive non-login shell::
+~/.bashrc+

non-interactive::
Value of envirnoment variable +BASH_ENV+ used as file name

=== Ubuntu

- +/etc/profile+
  * sources +/etc/profile.d/*.sh+
  * sources +/etc/bash.bashrc+
- +~/.profile+	
  * sources +~/.bashrc+
- +~/.bashrc+
  * sources +~/.bash_aliases+
  * sources +/etc/bash_completion+	


//////////////////////////////////////////////////////////////////////

Parameters
Parameter = Variable | PositionalParameter | SpecialParameter
An entity that stores a value

Positional Parameters
PositionalParameter = Digit+ except 0	
Positional parameters are assigned from the shell's argument. $1 is first argument, $2 second and so on. Maybe reassigned using set builtin, but not with variable assignment. A shell function has its own local positional parameters.

Special Parameters
SpecialParameter =
Shell treats these parameters specially. They are all const.

Variables
Variable = (Letter|_)(Letter|Digit|_)* ????
Variable is a parameter denoted with a name. A Variable has a name and one or more attributes. Is either set or unset.

Types
string

integer
No support for floating point. Range ???

array
Zero based. No limit for the size of the array. Members must not be indexed or assigned continously.

notes
There are no pointers or references or the like. 
Literals
IntegerLiteral = 
StringLiteral = SingleQuoteLiteral | DoubleQuoteLiteral
ArrayLiteral = ([[[subscript]=]scalar] ...)
Creation / Memory management
Variables are created when they are first referenced or declared, unless when options dictate otherwise. See -o nounset. 
Variables are released using unset. 
There is no freestore management like malloc / free in C. 
See also subchapter lifetime.
Declaration
Since variables are created when first referenced (see subchapter creation), there is no need for an explicit declaration. It is mandatory however if nounset is set to on, or to create integer variables????.
Globals
Variables are global when 
- implicetely created
- declared with declare outside a function

ExplicitStringDeclaration = declare (name[=string] )+ SD
ExplicitIntegerDeclaration = declare -i (name[=integer] )+ SD

ExplicitArrayDeclaration =
1) declare -a (name[[[subscript]][=scalar]] )+ SD
2) declare -a (name[=arrayliteral] )+ SD
If subscript is not given, then the index used is the index of the previous initializier incremented by one. Indexing starts at 0. 2) Arraycopy seems ??? not to be possible, i.e name=array 3), if subscript is provided, it is ignored.  
Locals
Variables are local when 
- declared using local
- declared using declare inside a function

Environment variables
Are just globals marked for export. See chapter environment variables.
Scope
globals	Dynamic scoping: from creation until unset 
			default
			declare	when not within a function
locals		Lexical scoping: from creation until end of block
			local		only within functions
			declare	when used within functions

Environment variables are just globals marked for export.
Lifetime
globals	from creation until end of script or until unset, whichever comes first
locals		from creation until end of block??(or function) ??unset

Environment variables are just globals marked for export.
Linkage
Since it is a scripting language, there is no linkage issue.
Operations
Referencing / Parameter expansion
name is just the string 'name', $name gets the value out of the variable with the name name. This is called parameter expansion. 

ScalarValueReference =
1) $ScalarName
2) ${ScalarName[parameteroperator]}
In arithmetic expressions, $ is optional. 2nd form must be used if name must be separated from any following text. E.g "${10}" evaluates to the 10nth positional argument, whereas "$10" evaluates to the first positional argmunent followed by "0".
ArrayElementValueReference = ${ArrayName[Subscript]}	see also operations array subscript

assignment
getaddress
scalar
assignment
scalar=[scalar]

array
assignment
1) array[subscript]=[scalar]
2) array=arrayliteral
subscripting 
${array[subscript]}
Curly braces are needed to avoid conflicts with shell's filename expansion operators.
 
Environment variables
set -a
set -k
declare -x
export

Miscellaneous
SD = \newline | ;    statement delimiter
Name = latin letters and numbers and underscore ???, case sensitive ???
Subscript = integer	Indexing starts at zero. The subscripts * and @ are special.
  
redirection operator: before a command executes, its input and output may be redirected.
<       redirect input
> >| >> redirect output
<< <<-  here document
<<<     here string
<&      duplicate input file descriptors
>&      duplicate output file descriptors
<&- >&- moving file descriptors
<>      open file descriptor for reading and writing

   

Reserved word:
! { } [[ ]]
 
control structs
 
if list; then list; [ elif list; then list; ] ... [ else list; ] fi
for (( ariexpr1 ; ariexpr2 ; ariexpr3 )) ; do list ; done
 
Quoting
 
escape character
\
Preserves literal value of next char (except <newline>)
single quotes
'
Preserves literal value of all enclosed chars.
double quotes
"
Preserves literal value of all enclosed chars with the following exceptions/notes:
$ retains special meaning
 retains special meaning
\ retains special meaning if followed by $   \ <newline>
* becomes special meaning
@ becomes special meaning
Ansi-c quoting
$
$string expands to characters as specified by the ansi-c standart
 
Expansion
 
brace expansion: a{b,c} expands to ab ac. May be nested. At leas one comma.
 
tilde expansion: If a word begins with unquoted ~, all chars to the next unquoted \ build the tildeprefix. Expands to various paths. ~ allone expands to $HOME
 
shell parameter expansion: $word or ${...}
 
command substitution: $(command) or `command`. All characters between the parantheses make up the command; none are treated specially.
 
arithmetic expansion: $((expression)). Expression is treated as if it were within double quotes.
 
process substitution: <(list) or >(list)
 
word splitting: Each char of $IFS is treated as an delimiter.
 
filename expansion: each word is scanned for * ? [
 
quote removal:
 
Arrays
set array = ( $< )
 
Redirection
 
[n]<word
Redirection of input causes the file whose name results from the expansion of word to be opened for reading on file descriptor n, or the standard input (file descriptor 0) if n is not specified.
[n]<&word
Word=a number: file descriptor denoted by n is made to be a copy of that file descriptor
Word=-: file descriptor n is closed
Word=[nothing]: standard input (file descriptor 0) is used
If n is not specified, the standard input (file descriptor 0) is used.
[n]<&digit-
moves the file descriptor digit to file descriptor n, or the standard input (file descriptor 0) if n is not specified. digit is closed after being duplicated to n.
 
[n]>[|]word
Redirection of output causes the file whose name results from the expansion of word to be opened for writing on file descriptor n, or the standard output (file descriptor 1) if n is not specified. If the file does not exist it is created; if it does exist it is truncated to zero size. If the redirection operator is `>|', or the redirection operator is `>' and the noclobber option is not enabled, the redirection is attempted even if the file named by word exists.
[n]>>word
Appends
&>word or >&word
Redirects stdout and stderr to the file word
[n]>&word
Word=[nothing]:standard output (file descriptor 1) is used
Word=number: file descriptor denoted by n is made to be a copy of that file descriptor
Word=-: ?
[n]>&digit-
moves the file descriptor digit to file descriptor n, or the standard output (file descriptor 1) if n is not specified.
 
[j]<>filename
causes the file whose name is the expansion of word to be opened for both reading and writing on file descriptor n, or on file descriptor 0 if n is not specified. If the file does not exist, it is created.
 
- [!! Not a bash operator, but an option recognized by certein unix utilities that write to stdout or read from stdin]
Redirect from/to stdin/stdout
Tar cf - . Make new archive (option c) into the file (option f) -, i.e. stdout, and do it in the current directory tree (.)
 
 
There are always three default "files" open, stdin (the keyboard), stdout (the screen), and stderr (error messages output to the screen)
 
Difference <&- and >&- ? Close for reading/writing, or totaly close?
Difference exec 3<> File and 3<> File?
When are files closed? Command >myfile
Unix command to see open file handles?


0 stdin
1 stdout
2 stderr
 
Duplicate filedescriptor:
[NDest]&<NSrc NDest is made a copy of word, i.e. everything read from NDest is actually read from word. Default for NDest is 0.
[NDest]&<-   NDest is closed
[NDest]>&NSrc NDest is made a copy of word, i.e. everything written to NDest is actually written to word. NDest defaults to 1 (stdout). As a special case, if N is omitted, and WORD
does not expand to one or more digits, the standard output and standard error are redirected as described previously.

Moving filedescriptor:
As Duplicating, however word is closed afterwards.
[NDest]&<NSrc-
[NDest]&>NSrc-

Distribute datastream:
tee [FILE]: Copy stdin to stdout and also to all listened files. Option -a appends to all given files.

Process substitution: The constructs can stand everywhere where a command expects a filename as an argument
<(list)
>(list)

 
key commands
 
movement
C-b      Move back one character.
C-f      Move forward one character.
C-a      Move to the start of the line.
C-e      Move to the end of the line.
M-f      Move forward a word, where a word is composed of letters and digits.
M-b      Move backward a word.
C-l      Clear the screen, reprinting the current line at the top.
 
deleting
DEL or Backspace      Delete the character to the left of the cursor.
C-d      Delete the character underneath the cursor.
 
kill & yank
C-k      Kill the text from the current cursor position to the end of the line.
M-d      Kill from the cursor to the end of the current word, or, if between words, to the end of the next word. Word boundaries are the same as those used by M-f.
M-DEL Kill from the cursor the start of the current word, or, if between words, to the start of the previous word. Word boundaries are the same as those used by M-b.
C-w   Kill from the cursor to the previous whitespace. This is different than M-DEL because the word boundaries differ.
 
C-y      Yank the most recently killed text back into the buffer at the cursor.
M-y      Rotate the kill-ring, and yank the new top. You can only do this if the prior command is C-y or M-y.
C-p      paste-from-clipboard ( \C-p: paste-from-clipboard in .inputrc )
            Putclip
            getclip
           
misc
C-_ or C-x C-u          Undo the last editing command. You can undo all the way back to an empty line.
 
history
 
C-r      incremental backward search in history
C-s      incremental forward search in history
C-g      abort incremental search
 
The characters present in the value of the isearch-terminators variable are used to terminate an incremental search. If that variable has not been assigned a value, the ESC and C-J characters will terminate an incremental search.
 
 
 
Readline variables
bind V     lists the current Readline variable names and values. See section 4.2 Bash Builtin Commands.
 
////////////////////////////////////////////////////////////////////// 
 
 
