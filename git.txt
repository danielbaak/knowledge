= Git

== Inspection

Contents of a file at a certain revision::
  ++git show++. Alternatively use ++git checkout++ and you'll have the files in
  your working directory.

Human digestable name of a revision::
  ++git name-rev++, ++git describe++

Diff of two revisions::
  ++git diff++

Commit logs::
  ++git log++ (++git-rev-list++ as the low level alternative from the plumbing section).

Status of working tree / index file::
  ++git status++

== Transitions

The following copy files between the following three participants: the working
tree, the index aka the staging area and the repository.

.Working tree -> Index
- all but ignored: ++git add -A++
- single files: ++git add <pathspec>...++

.Working tree -> index and new commit in repository
I.e. additionally HEAD is modified.
Its not possible to only copy to repository but not also to index.
- all (which are also in index): ++git commit -a++
- single files (which must also be in index): ++git commit <file>...++

.Remove from working tree
- single files: ++/bin/rm <file>...++

.Index -> new commit in repository
I.e. additionally HEAD is modified
- all: ++git commit++

.Index -> Working tree
- all: ++git checkout-index -a++
- single files: ++git checkout-index <file>...++

.Remove from Index
- single files: ++git rm --cache <file>...++

.Repository -> Index
- ???

.Repository aka HEAD -> working tree
- ???

.Remove from repository
Fortunately not directly possible.  When commits, or git objects in general,
become unreachable, eventually they will be pruned by the garbage collector.


== Undo Mistakes
In addition to what is under chapter transitions.

++git revert++:: Add a new commit which undoes the given commit
++git reset++::
++git commit --amend++::
++git checkout -f++:: Throw away local changes
++git filter-branch++::
++git rebase++::

== Terms

See also gitglossary(7) man page.

== Questions

What's the difference between ++git log++ and ++git rev-list++?::
  They are mostly the same. log is from the porcelain layer, rev-list from
  plumbing, thus rev-list is seldom used. There are only a few things rev-log
  can do which log can't. See also
  http://www.amailbox.org/mailarchive/git/2008/5/30/1983864/.

Refspec for fetch::
  Note that the fully qualified name for local branches is refs/heads/<name>, and for remote tracking branches its refs/remotes/<remote-name>/<name>. See also SPECIFYING REVISIONS in git-rev-parse(1). Thus fetching only some branches results in e.g. (`refs' already left away) ++fetch origin R8.0:remotes/origin/R8.0 R9.1:remotes/origin/R9.1++. Still, why does it now I don't mean a local branch FQN 'refs/remotes/origin/R9.1`? It `missinterprets' ++fetch origin R9.1:origin/R9.1++ and ++fetch origin R9.1:R9.1++. The more basic Question maybe is: what are the rules as in SPECIFYING REVISIONS in git-rev-parse(1) when creating (opposed to lookup) a ref name?
	

- What happens with the `branch name/reference' after merging?
- Where is the beginning of a branch, i.e. up to where does ++git branch -d++
  delete? Possibly the commit given when the branch was created?
- What's the difference between a reamote branch and a branch. Why is it `only'
  remote? I made a clone, didn't I?
- upstream branch?
- From http://stackoverflow.com/questions/67699/how-do-i-clone-all-remote-branches-with-git
----------------------------------------------------------------------
If you just want to take a quick peek at an upstream branch, you can check it out directly:
$ git checkout origin/experimental
But if you want to work on that branch, you'll need to create a local tracking branch:
$ git checkout -b experimental origin/experimental
----------------------------------------------------------------------
Why is the first checkout not good enough? what happens if i do git commit there?
- difference ++git reset++ +--hard+/+--soft+. Now does both completely remove
  commits or not? Or is a new commit created which undoes the unwanted commits?
- `You can check out those (remote) branches like a normal branch, but you should
  not change them.' So, what would happen?
- what exactly does ++git branch -d++ delete? Only the reference, or also commits?
- difference revision - commit? Add to terms
- What's the difference between ++git describe++ and ++git name-rev++?



== Cotchas
- After resolving merge conflicts, or after doing anything to your files after automatic merge without automatic commit, make sure to add all the changes you want to the index, and thus to the next commit, (typically all) with +git add+.
- *rebase*: if you merge two branches which are based upon a commit with wrong eol (but the branch heads are ok), you're in hell. try use tortoise conflict editor, it doesn't see the whole file as in conflict.
- *sync*: Pushing changes to remote how? Currently I push unmerged feature branches and merge on the `central' (aka ~vss) repo.

== SmartGitHg

=== cumbersome to use / missing featurres
- See Guis/Rebase
- when merging to branches, the commit message has includes the sha1 of the merged commit instead the branch name (may

=== bugs
- saves with eol unix style (mindestens merge conflict editor).
  * find -iname '*.cpp' -o -iname '*.h' | xargs perl -ne 'if (/\n/ && !/\r\n/) { print "$ARGV:$.:"; close ARGV } if (eof) {close ARGV}'
	* find -iname '*.cpp' -o -iname '*.h' | xargs perl -ne 'if (/\n/ && !/\r\n/) { print "$ARGV\n"; close ARGV }' | xargs unix2dos


== Git command notes / howtos

Summary of manuals tailored towards me. Notes on how to (best) use certain git commands

== Fetch
refspec:
  src: <refname> applyied within the remote repo. Howto resolve, see git-rev-parse(1)/SPECIFYING REVISIONS/<refname>
	dst: <refname> applyied within the local repo. Howto resolve, see ??? probably again git-rev-parse(1), but the name must be almost fully qualified, only "refs/" can be left away.
	
== Pull
refspec: see chapter fetch

Which branch to merge into HEAD: see git-pull(1)/DEFAULT BEHAVIOUR


=== Rebase

==== Cookbook
- ++git rebase -i++
- Edit, remove changes:
  * ++git reset --soft++
	* Edit index with smart git. That only works if one of the sides is the working tree. For that, you may have to unstage the file in question. Alternatively, you can use the edit index feature. 
	* ++git commit -a -c HEAD{1}++
	* ++git rebase --continue++

==== Problems
CLI::
- Funny problems when files are on a cifs. It seems that they go away when client's clock is ahead of server's clock.
Gitk::
Does not offer it
SmartGit::
- Apperently can not nicely rebase two branches, only a commit onto a branch, or a branch onto its tracking branch.
- The original head moves (which it shoudn't) and the from-branch is not moved (only the commits). 
- Note the eol bug of the conflict resolution editor
Tortoise::
- _Bug_ I again haid funny eol problems when rebasing a branch upon another. One file had the wrong line teminator. Git (CLI) had no problem doing it.
- _Bug_ Suash does not work, it behaves as pick
- _Kludge_ List is inverse compared to how +git rebase -i+ does it.
- Nice `interactive rebase' editor.
- From Shell (i.e. context menu) can only rebase branches onto branches.
- From Log can rebase current branch
onto arbitrary commit.
Git Extensions::
- _Bug_ The last rewritten commit behaves funny, it seems to remove all files.

=== Graphical log
- Tortoise and QGit are the only ones that displays it in a way I find it convenient

//  LocalWords:  pathspec
