\documentclass{article}

\begin{document}
\author{Florian Kaufmann}
\title{Bash Summary}
\date{\today}
\maketitle
\tableofcontents

\section{Abstract}

\section{Introduction}

\section{Structure of a bash program}


Bash scrips basically are composed of Lists, which are composed of
Pipes, which are composed of Commands, which are composed of Words. The
first word of a command is the command name, the following words are the
arguments passed to the command. (Standart-)input and (standart-) output
of commands can be redirected using pipes and redirections.

Commands are callable/executable code. E.g. executable files on the file
system, or builtins of bash, or bash script functions.

The lists, i.e. at the the end commands, are executed as they appear in
the script.

To lessen redundant code, one can define functions and call them like
regular commands.

\section{Atoms}

Logcical Line =
Physical Line =
Misc terms
Blank = \space | \t
Metacharacter = OneOf Blank |  & ; ( ) < >  	separates words
Operator = ControlOperator | RedirectionOperator
ControlOperator = OneOf || & && ; ;; ( ) | \n 	a token that performs a control function
Token = 
Word =
ReservedWord = Word that has special meaning to the shell


\section{Lists, Pipes, Commands}

\subsection{Lists}

\begin{verbatim}
## A sequence of characters considered a single unit by the shell        
Token = Operator|Word;
        
nOperator = ControlOperator|RedirectionOperator;
        
ControlOperator =
  \n | '|| | '&& | '& | '; | ';; | '|  | '( | ') ;
        
## A token that is not an operator is a word         
Word = ;        
        
## When unquated, separates words.
MetaCharacter = Blank | \& | \; | \( | \) | \< | \>;  	
        
Blank = " " | \t;
                
Name = '[a-zA-Z_]'[0-9a-zA-Z_]*;
Identifier = Name;                
        
# A word that has a special meaning to the shell        
KeyWord = ReservedWord;        
ReservedWord =
  \! | "[[" | `]]  | \{ | \} | 
  'case | 'do | 'done | 'elif | 'else | 'esac |
  'fi | 'for | 'function | 'if | 'in | 'select |
  'then | 'time | 'until | 'while;
\end{verbatim}

% Metacharacters:
% !!! Doesn seem to be a complete list:
% \" ' ` ! \\ $
% Seems like Metacharacters have to divided into
% wordsepratating ones and the others        

\subsection{Comments}

\begin{verbatim}
Comment = # ... \n;        
\end{verbatim}

Text between an unquoted \verb|\#| and the end of the line counts as comment and
is ignored.

\section{Lists, Pipes, Commands}

\subsection{Commands}

\begin{verbatim}
Command = SimpleCommand | CompoundCommand;

SimpleCommand =
  $simple      
  VarAssignment* Word#CmdName Word*#Args Redirection*;
  $medium
  (VarAssignment|Redirection)+ |. (Word|Redirection)+;      
        
CompoundCommand = 	
  (GroupingCommand |
   LoopingCommand |        
   ConditionalCommand )
  Redirection*; 
\end{verbatim}

1) Manual says \emph{redirections} are part of a simple command. I think
they are really part of a command. For simple commands, redirections can
appear distributed anywhere between distinctict words of the simple
command. For compound commands, they can only appear at the end. ??? I
don't know what the rules are if redirections/pipe contradict/conflict,
e.g. if stdout is redirected to two different things, or if a file is
written two by two diffrent fd's.

The \b{return status} of a simple command is its \b{exit status} as
provided by the POSIX 1003.1 `waitpid' function, or 128+N if the command
was terminated by signal N.


\subsection{Pipes}

A pipe combines commands; the std output of the right command of a pipe
operator \verb#|# is redirected to the std input of the left comand.

\begin{verbatim}
Pipe = ['time ["-p"]] [\!#NegExit] (Command \|{~} )+;  
\end{verbatim}

Each command in a pipeline is executed in its own subshell. The exit
status of a pipeline is the exit status of the last command in the
pipeline (this can be altered by pipefail option). If the keyword
\verb|!| precedes the pipe, the exit status is logically inverted.

The shell waits for all commands in the pipeline to terminate before
returning a value.

The keyword \verb|time| causes timing statistics to be printed; the option -p
changes the ouptut format to that specified by POSIX.

% ??? Why is \verb|time;| valid but neither of ";" "! ;"??? Either an empty
% command is allowed or not.

% ??? Why doesnt this work \verb|time && time| This at least works
% \verb|time echo && time echo|.

\subsection{Lists}

A list combines pipes.

\begin{verbatim}
List           = ( AndOrList OpAndOrList{~} )+ [Op2AndOrList]; 
AndOrList      = ( Pipe OpPipe{~} )+; 
OpPipe         = `&& #And    | `|| ;#Or
OpAndOrList    = `&  #Async  | `;  ;#Sync
Op2AndOrList   = OpAndOrList | \n  ;#Sync    
\end{verbatim}

\emph{And combination} \verb|&&|: Right pipe is only executed if left
pipe's exit status is 1. Combined exit status is the result of a logical
and operation on the exit status of the two pipes.

\emph{Or combination} \verb#||#: Right pipe is only executed if left
pipe's exit status is 0. Combined exit status is the result of a logical
or operation on the exit status of the two pipes.

\emph{Async sublist} \verb|&|: Executes sublist asynchronously in a
subshell, also known as executing it in the background. See also job
control how to figure out when it finished and with what exit status.

\emph{Sync sublist} \verb|;|: Executes the sublist synchronous to current shell.

The manual sometimes also uses command list as synonym for list.

% It is not 100\% clear to me where ; is optional and where not.
% UnaryListOp might be optional because for e.g. the last command in ( )
% or in { } does not have to have a terminator.

\section{Compound commands / flow control}

\subsection{Grouping }

\begin{verbatim}
GroupingCommand =        
  `( List `) |            ## Executed in subshell.  
  `{ List `} |            ## Executed in current shell. 
  `(( ArithmeticExp `)) | ## Arithmetic evaluation 
  `[[ CondExp `]] ;	      ## Conditional Expression. 
\end{verbatim}

\subsection{Conditional commands }

\begin{verbatim}
## Use break continue to control loop execution        
LoopingCommand =
  'until List#Test 'do List |
  'while List#Test 'do List |
  'for Name ['in Word* |> `"$@" ] SD 'do List 'done |
  'for '(( [AritExp|>'1] `; [AritExp|>'1] `; [AritExp|>'1] `)) `;
    'do List 'done;

ConditionalCommand =
  'if List#Test 'then List                
  ('elif List#Test 'then List)*
  ['else List]
  'fi |

  ## the first clause which's pattern list machtes Word will be executed     
  'case Word 'in
  ( (Pattern \|{0}#Or )+ `) List `;; )#Clause*     
  'esac |
        
  'select Name [in Word*|>`"$@" ] 'do List 'done
\end{verbatim}

Tests are true when the exit status is 0. The exit status of the whole
looping command is the exit status of the last command in the body, or 0
if no command was executed.



\subsection{Looping commands }

\section{Redirections}

See also Command where redirections can appear. Redirections are
processed from left to right. See also exec built in for how to operate
on file descriptors of current shell, in contrast to subshell of command
to be called.

\begin{verbatim}
        
## FdWord and Filename respectively are expanded. If the expanded
## FdWord does not result in a filedescriptor open for input/output, a
## redirection error occures.
Fd = '[0-9]+;			
FdWord = Word;        
FileName = Fd | Word;
        
Redirections =	
  [Fd] (
    ## redirecting input, i.e. open fd for input        
    `<  |
  
    ## redirecting output, i.e. open fd for output
    `>  | ## fails if file already exists (see option noclobber)
    `>| | ## always create new file
    `>> | ## appends
        
    ## open fd for in- and ouptut       
    `<> )
  Filename |
        
  ## Redirect std output and std error (just syntax sugar)
  (`&> | `>& ) FileName |       
        
  ## close fd. < for fd's open for input, > analogous. 
  [Fd] (\<|\>)\- |
        
  ## Duplicate/Move fds: Fd=FdWord. If - is given, close FdWord afterwards.
  [Fd] (\<|\>)\&FdWord[\-] |
        
  ## Here string. Word is expanded and supplied as input
  [Fd] `<<< Word | 
        
  ## Here documents. The text upto a line containing *only* the delimiter
  ## is supplied as input.
  ## No expansion is done on word following <<[-]
  $simple
  [Fd] "<<"[\-] Word#Del ... #Del     
        
  $medium      
  [Fd] "<<"[\-] @Del(Word) ... \n ## rest of cmd upto 1st unqoted \n
    ...        ## here document, incl trailing newline
    @>Del\n;   ## line containing only delimiter  
\end{verbatim}

\begin{verbatim}
Fd is short for file descriptor. If not supplied it defaults to 0 (i.e.
std input) for input redirections and for <>. For output redirections it
defaults to 1 (i.e. std out).

The file descriptor must be given literally, it can not come from an
expanded parameter as in "fd=1; mycmd fd>out.txt;"

redirecting input, I.e. open filedescriptors for input-)
[Fd] < Filename
FdList[fd].open( read, filename )

redirecting output, I.e. open filedescriptors for output
>) [Fd] (>|>||>>) Filename			
>	FdList[fd].open( write | create, filename ) // fails if file exist and noclobber
>|	FdList[fd].open( write | create, filename ) // always creates new file
>>	FdList[fd].open( write | append, filename )


open file descriptors for input and output
-) [Fd] <> Filename		FdList[fd].open( write | write | create, filename ) // ???

close file descriptors
-) [Fd] (<|>)-			FdList[fd].close()
< must be used if fd is open for input, and > if fd is open for output. If done wrongly, an error occurs.

duplicating/moving file descriptors
-) [Fd] (<|>)&FdWord[-]		FdList[fd] = FdList[fd2]; if ( - supplied ) FdList[fd2].close(); 	

An error occures if < is used and fd2 is not open for input. Analogous
for > and beeing open for output.

here documents
-) [Fd] << [-] Delimiter 	
\end{verbatim}

After the list(?) any sequence of characters form the input, until a
line which ONLY contains delimiter. Details: Delimiter can be any word.
No parameter expansion, command substitution, arithmetic expansion, or
filename expansion is performed on Delimiter. If any characters in WORD
are quoted, the DELIMITER is the result of quote removal on WORD, and
the lines in the here-document are not expanded. If Delimiter is
unquoted, all lines of the here-document are subjected to parameter
expansion, command substitution, and arithmetic expansion. If the
redirection operator is ``<<-'', then all leading tab characters (only
tab, no other white spaces) are stripped from input lines and the line
containing DELIMITER. This allows here-documents within shell scripts to
be indented in a natural fashion.

Multiple here docments in a list are possible. See help for
quoting/expansion rules for Delimiter and suplied input.


\section{Quoting}



\section{Variables}

\section{Functions}


\section{Command line processing}


When is it splitt into lists/pipes/compound commands/commands ?

\begin{description}
\item[Tokenize]
  \begin{itemize}
  \item Split into tokens, i.e. words and operators. Exp in Arithmetic
        expression behaves as in double quotes, but a double quote within is not
        treaded specially.
   \item If first token is a) an opening keyword, read next command and goto
         tokenize b) an alias, expand alias and goto tokenize c) another
         keyword, its a syntax error.
  \end{itemize}
  
\item[Each so resulting word undergoes then] brace expansion
  
\item[Each so resulting word undergoes then]   
  \begin{itemize}
  \item Tilde expansion.
  \item Parameter expansion. DQ, 1)
  \item Command substitution. DQ
  \item Arithmetic substitution. DQ
  \end{itemize}
  
\item Process substituion. 
\item Word splitting. NW
\item Pathname expansion. NW
\item Quote removal 
  
\item[Command lookup] 
  First word is the command name, the following words are arguments. If command
  name is \verb|eval|, concatenate arguments into a single string and goto
  tokenize. Else setup environment and run command.
\end{description}

\begin{description}
\item[DQ] Also within double quotes
\item[NW] Can change the number of words. That has effect on the following steps.
\end{description}

1) [$@ and ${NAME[@]} CanChange@OfWords]  

\begin{verbatim}
# the words resulting from brace expansion are eligble for the rest of the
# expansions.
$ echo ~{flo,edi} 
/home/flo /home/edi
$ xpostfix=1; ypostfix=2;
$ echo {$x,$y}postfix
1 2

# Expansions (except brace- and filename-) do not change number of words. 
# It's word splitting who does that.
$ echo flo_text > flo; echo edi_text > edi
$ cat $(ls edi flo)
edi_text
flo_text
$ IFS=""; cat $(ls edi flo)
cat: edi
flo: No such file or directory
\end{verbatim}

Add to table where whites are removed (e.g. command subst, proc subst)  
  


\section{Expansions}

\begin{verbatim}
## Brace Expansion
## --------------------
BraceExpansion = [Preamble]\{(Seq|(EltStr\,{~}){2,})\}[Postscript];
  Seq = Num".."Num | Char".."Char;
  Num = ['[+-]]'[0-9]+;
  Char = \a;
  Str = %simple \a* %exact ('[^\\,}]*[\\'[\\,}\s]])*;
Word <=| BraceExpansion;   
     
## The given word is replaced by the resulting space separated list
     
## Notes:
## - The string "${..." is not eligble for the start ofbrace expansion
## - A literal { , \ or space must be quoted with \   
## - echo {a,b}$PATH becomes echo a$PATH b$PATH which in turn is expanded later   
##   echo $x{a,b} becomes echo $xa $xb , and $xa $xb are probably not defined
## - {0,1}{0,1}... is like {0,1}({0,1}(...)), i.e. the left is the preamble
##   of the following
## Warnings:
## - Im not sure about more whites than space must/can be quoted with \

## Tilde Expansion
## --------------------
TildeExpansion = \~(TildePrefix)[\/[WordTail]];
  
TildePrefix =
  `+  | ## PWD
  `-  | ## OLDPWD (actually ${OLDPWD-'~-'})
  Num | ## directory stack elt, i.e. output of 'dirs Num'
  UserName; 
UserName =
  ""  |  ## HOME
  %simple
  Word   ## home dir associated with that username
  %exact
  ^(Blank|'[\\/])+; ## ?? no idea if that is right

 Num = ['[+-]]'[0-9]+;
 
Word <=| TildeExpansion;               
     
## If anything fails, the word is left unchanged               
\end{verbatim}

\end{document}



Parameters
Parameter = Variable | PositionalParameter | SpecialParameter
An entity that stores a value

Positional Parameters
PositionalParameter = Digit+ except 0	
Positional parameters are assigned from the shell's argument. $1 is first argument, $2 second and so on. Maybe reassigned using set builtin, but not with variable assignment. A shell function has its own local positional parameters.

Special Parameters
SpecialParameter =
Shell treats these parameters specially. They are all const.

Variables
Variable = (Letter|_)(Letter|Digit|_)* ????
Variable is a parameter denoted with a name. A Variable has a name and one or more attributes. Is either set or unset.

Types
string

integer
No support for floating point. Range ???

array
Zero based. No limit for the size of the array. Members must not be indexed or assigned continously.

notes
There are no pointers or references or the like. 
Literals
IntegerLiteral = 
StringLiteral = SingleQuoteLiteral | DoubleQuoteLiteral
ArrayLiteral = ([[[subscript]=]scalar] ...)
Creation / Memory management
Variables are created when they are first referenced or declared, unless when options dictate otherwise. See -o nounset. 
Variables are released using unset. 
There is no freestore management like malloc / free in C. 
See also subchapter lifetime.
Declaration
Since variables are created when first referenced (see subchapter creation), there is no need for an explicit declaration. It is mandatory however if nounset is set to on, or to create integer variables????.
Globals
Variables are global when 
- implicetely created
- declared with declare outside a function

ExplicitStringDeclaration = declare (name[=string] )+ SD
ExplicitIntegerDeclaration = declare -i (name[=integer] )+ SD

ExplicitArrayDeclaration =
1) declare -a (name[[[subscript]][=scalar]] )+ SD
2) declare -a (name[=arrayliteral] )+ SD
If subscript is not given, then the index used is the index of the previous initializier incremented by one. Indexing starts at 0. 2) Arraycopy seems ??? not to be possible, i.e name=array 3), if subscript is provided, it is ignored.  
Locals
Variables are local when 
- declared using local
- declared using declare inside a function

Environment variables
Are just globals marked for export. See chapter environment variables.
Scope
globals	Dynamic scoping: from creation until unset 
			default
			declare	when not within a function
locals		Lexical scoping: from creation until end of block
			local		only within functions
			declare	when used within functions

Environment variables are just globals marked for export.
Lifetime
globals	from creation until end of script or until unset, whichever comes first
locals		from creation until end of block??(or function) ??unset

Environment variables are just globals marked for export.
Linkage
Since it is a scripting language, there is no linkage issue.
Operations
Referencing / Parameter expansion
name is just the string 'name', $name gets the value out of the variable with the name name. This is called parameter expansion. 

ScalarValueReference =
1) $ScalarName
2) ${ScalarName[parameteroperator]}
In arithmetic expressions, $ is optional. 2nd form must be used if name must be separated from any following text. E.g "${10}" evaluates to the 10nth positional argument, whereas "$10" evaluates to the first positional argmunent followed by "0".
ArrayElementValueReference = ${ArrayName[Subscript]}	see also operations array subscript

assignment
getaddress
scalar
assignment
scalar=[scalar]

array
assignment
1) array[subscript]=[scalar]
2) array=arrayliteral
subscripting 
${array[subscript]}
Curly braces are needed to avoid conflicts with shell's filename expansion operators.
 
Environment variables
set -a
set -k
declare -x
export

Miscellaneous
SD = \newline | ;    statement delimiter
Name = latin letters and numbers and underscore ???, case sensitive ???
Subscript = integer	Indexing starts at zero. The subscripts * and @ are special.
  
redirection operator: before a command executes, its input and output may be redirected.
<       redirect input
> >| >> redirect output
<< <<-  here document
<<<     here string
<&      duplicate input file descriptors
>&      duplicate output file descriptors
<&- >&- moving file descriptors
<>      open file descriptor for reading and writing

   

Reserved word:
! { } [[ ]]
 
control structs
 
if list; then list; [ elif list; then list; ] ... [ else list; ] fi
for (( ariexpr1 ; ariexpr2 ; ariexpr3 )) ; do list ; done
 
Quoting
 
escape character
\
Preserves literal value of next char (except <newline>)
single quotes
'
Preserves literal value of all enclosed chars.
double quotes
"
Preserves literal value of all enclosed chars with the following exceptions/notes:
$ retains special meaning
 retains special meaning
\ retains special meaning if followed by $   \ <newline>
* becomes special meaning
@ becomes special meaning
Ansi-c quoting
$
$string expands to characters as specified by the ansi-c standart
 
Expansion
 
brace expansion: a{b,c} expands to ab ac. May be nested. At leas one comma.
 
tilde expansion: If a word begins with unquoted ~, all chars to the next unquoted \ build the tildeprefix. Expands to various paths. ~ allone expands to $HOME
 
shell parameter expansion: $word or ${...}
 
command substitution: $(command) or `command`. All characters between the parantheses make up the command; none are treated specially.
 
arithmetic expansion: $((expression)). Expression is treated as if it were within double quotes.
 
process substitution: <(list) or >(list)
 
word splitting: Each char of $IFS is treated as an delimiter.
 
filename expansion: each word is scanned for * ? [
 
quote removal:
 
Arrays
set array = ( $< )
 
Redirection
 
[n]<word
Redirection of input causes the file whose name results from the expansion of word to be opened for reading on file descriptor n, or the standard input (file descriptor 0) if n is not specified.
[n]<&word
Word=a number: file descriptor denoted by n is made to be a copy of that file descriptor
Word=-: file descriptor n is closed
Word=[nothing]: standard input (file descriptor 0) is used
If n is not specified, the standard input (file descriptor 0) is used.
[n]<&digit-
moves the file descriptor digit to file descriptor n, or the standard input (file descriptor 0) if n is not specified. digit is closed after being duplicated to n.
 
[n]>[|]word
Redirection of output causes the file whose name results from the expansion of word to be opened for writing on file descriptor n, or the standard output (file descriptor 1) if n is not specified. If the file does not exist it is created; if it does exist it is truncated to zero size. If the redirection operator is `>|', or the redirection operator is `>' and the noclobber option is not enabled, the redirection is attempted even if the file named by word exists.
[n]>>word
Appends
&>word or >&word
Redirects stdout and stderr to the file word
[n]>&word
Word=[nothing]:standard output (file descriptor 1) is used
Word=number: file descriptor denoted by n is made to be a copy of that file descriptor
Word=-: ?
[n]>&digit-
moves the file descriptor digit to file descriptor n, or the standard output (file descriptor 1) if n is not specified.
 
[j]<>filename
causes the file whose name is the expansion of word to be opened for both reading and writing on file descriptor n, or on file descriptor 0 if n is not specified. If the file does not exist, it is created.
 
- [!! Not a bash operator, but an option recognized by certein unix utilities that write to stdout or read from stdin]
Redirect from/to stdin/stdout
Tar cf - . Make new archive (option c) into the file (option f) -, i.e. stdout, and do it in the current directory tree (.)
 
 
There are always three default "files" open, stdin (the keyboard), stdout (the screen), and stderr (error messages output to the screen)
 
Difference <&- and >&- ? Close for reading/writing, or totaly close?
Difference exec 3<> File and 3<> File?
When are files closed? Command >myfile
Unix command to see open file handles?


0 stdin
1 stdout
2 stderr
 
Duplicate filedescriptor:
[NDest]&<NSrc NDest is made a copy of word, i.e. everything read from NDest is actually read from word. Default for NDest is 0.
[NDest]&<-   NDest is closed
[NDest]>&NSrc NDest is made a copy of word, i.e. everything written to NDest is actually written to word. NDest defaults to 1 (stdout). As a special case, if N is omitted, and WORD
does not expand to one or more digits, the standard output and standard error are redirected as described previously.

Moving filedescriptor:
As Duplicating, however word is closed afterwards.
[NDest]&<NSrc-
[NDest]&>NSrc-

Distribute datastream:
tee [FILE]: Copy stdin to stdout and also to all listened files. Option -a appends to all given files.

Process substitution: The constructs can stand everywhere where a command expects a filename as an argument
<(list)
>(list)

 
key commands
 
movement
C-b      Move back one character.
C-f      Move forward one character.
C-a      Move to the start of the line.
C-e      Move to the end of the line.
M-f      Move forward a word, where a word is composed of letters and digits.
M-b      Move backward a word.
C-l      Clear the screen, reprinting the current line at the top.
 
deleting
DEL or Backspace      Delete the character to the left of the cursor.
C-d      Delete the character underneath the cursor.
 
kill & yank
C-k      Kill the text from the current cursor position to the end of the line.
M-d      Kill from the cursor to the end of the current word, or, if between words, to the end of the next word. Word boundaries are the same as those used by M-f.
M-DEL Kill from the cursor the start of the current word, or, if between words, to the start of the previous word. Word boundaries are the same as those used by M-b.
C-w   Kill from the cursor to the previous whitespace. This is different than M-DEL because the word boundaries differ.
 
C-y      Yank the most recently killed text back into the buffer at the cursor.
M-y      Rotate the kill-ring, and yank the new top. You can only do this if the prior command is C-y or M-y.
C-p      paste-from-clipboard ( \C-p: paste-from-clipboard in .inputrc )
            Putclip
            getclip
           
misc
C-_ or C-x C-u          Undo the last editing command. You can undo all the way back to an empty line.
 
history
 
C-r      incremental backward search in history
C-s      incremental forward search in history
C-g      abort incremental search
 
The characters present in the value of the isearch-terminators variable are used to terminate an incremental search. If that variable has not been assigned a value, the ESC and C-J characters will terminate an incremental search.
 
 
 
Readline variables
bind V     lists the current Readline variable names and values. See section 4.2 Bash Builtin Commands.
 
 
 
 
