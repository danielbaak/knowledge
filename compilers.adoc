:encoding: UTF-8
// The markup language of this document is AsciiDoc. 

= Compilers -- Principles, Techniques and Tools

A summary of the book with the same title.

A '(formal) language' is a set of words.  A 'word' (or 'sentence'?)  is a
sequence of 'symbols'.  The 'alphabet' of a formal language is the set of
available symbols.

A 'lexical analyzer' (aka 'lexer', 'tokenizer', 'scanner') performs 'lexical
analysis', which is the process of converting a sequence of characters into a
sequence of tokens.  A 'token' consists of a token name and an attribute
value.  The 'token name' is an abstract symbol.  It is often used as terminal
symbol in a context free grammar.  The 'attribute value' is optional
additional information about the token.

A 'context free grammar' (aka 'concrete syntax') defines a formal language.  It
consists of the following:

* A set of 'terminal (symbols)'.  In other words the alphabet of the formal
  language being defined by the grammar.  A terminal corresponds to token
  name.
* A set of 'nonterminal (symbols)' aka 'syntactic variables'.
* A set of 'production (rules)'.  A production consists of a head and a body.
  The 'head' (aka 'left side') is a nonterminal.  The 'body' (aka 'right
  side') is a sequence of grammar symbols.  The term 'Grammar symbol' is the
  generalization of terminal symbol and nonterminal symbol.
* A designation of one of the nonterminals as the 'start' symbol. 

The letter G is often used as the name of the grammar at hand.  A 'single
production' is a production whose body consists of a single nonterminal, and
nothing else.

Notational Conventions:

* terminal symbol: early lowercase letter (a, b, c, ...), digit, punctuation,
  boldface string (*if*, *else*, ...).
* nonterminal symbol: early uppercase letter (A, B, C, ...), the letter S,
  lowercase italic string ('expr', 'term', 'factor', ...).
* grammar symbol: late uppercase letter (..., X, Y, Z).
* string of terminal symbols: late lowercase italic letters ('u', 'v', ...,
  'z').
* string of grammar symbols: lowercase Greek letter (α, β, γ, ...).

'Derivation' is the process of starting with the start nonterminal symbol of a
grammar and successively replacing a nonterminal symbol by the body of one of
its productions.  If the leftmost (or rightmost) nonterminal is always
replaced, then it's a 'leftmost derivation' (respectively, 'rightmost
derivation').  When a sequence of derivation steps rewrite α~1~ to α~n~, we
say α~1~ 'derives' α~n~.  The symbol => means ``derives in one step''. With a
Kleene star above it means ``derives in zero or more steps'', with a plus
above it means ``derives in one ore more steps'', with an 'lm' below it means
``leftmost derivation'', with an 'rm' below it means ``rightmost derivation''.
If α derives from S, where S is the start symbol of α grammar G, we say that α
is a 'sentential form' of G.  When S derives α by a leftmost derivation, then
we say that α is a 'left-sentential form' of the grammar at hand.  Analogous
for 'right-sentential form'.  Rightmost derivations are sometimes called
'canonical' derivations.  A 'sentence' of G is a sentential form with only
terminal symbols, possibly none.  A language that can be generated by a
grammar is said to be a 'context-free language'.  If two grammars generate the
same language, the grammars are said to be 'equivalent'.

A 'parse tree' (aka 'concrete syntax tree') is a graphical representation of a
derivation that filters out the order in which the productions are applied to
replace nonterminals.  Each interior node represents the application of a
production and is labeled with the head.  I.e. each interior node represents a
nonterminal.  The children are labeled, from left to right, by the grammar
symbols in the body.  The leaves of a parse tree, read from left to right,
constitute a sentential form, called the 'yield' or 'frontier' of the tree.
See also abstract syntax tree for a similar concept.

Every parse tree has associated with it a unique leftmost and a unique
rightmost derivation.  An 'ambiguous' grammar is one that produces more than
one leftmost derivation or more than one rightmost derivation for the same
sentence.

A grammar is 'left recursive' if it has a nonterminal A such that there is a
derivation A =>+ Aα for some string α.  'Immediate left recursion' is where
there is a production of the form A -> Aα.

'LL(1) grammar class': The first L stands for scanning the input from left to
right, the second L stands for producing a leftmost derivation, and the 1 for
using one input symbol of lookahead.

??? those properties are those of a machine doing derivations, not of the
grammar itself???

'Bottom-up parsing' is the process of 'reducing' a string of terminal symbols
to the start nonterminal symbol.  A 'reduction' is by definition the reverse
of a step in a derivation.

In an '(Abstract) syntax tree (AST)' each interior node represents an
operator; the children of the node represent the operands of the operator.
Any (programming) construct in the source language is handled by making up an
operator for the construct and treating as operands the semantically
meaningful components of that construct.  AST and parse tree (aka concrete
syntax tree) resemble each other.  However in an parse tree interior nodes
represent nonterminals.  Not all nonterminals represent programming
constructs, e.g. they are just ``helpers'' of one sort of another, thus in an
AST they are not needed and are hence dropped.

A 'Syntax-directed definition (SDD)' is a grammar extended as follows: A set
of attributes is associated with each grammar symbol and zero or one semantic
action is associated with each position in a production rule.  An 'attribute'
is any quantity.  A 'semantic rule' (aka '(semantic) action') computes the
values of the attributes associated with the symbols appearing in the
production.  Typically, there is a semantic action at the end of a production
rule.  By convention, semantic actions are enclosed with curly braces.  A
'S-attributed' SDD is one that involves only synthesized attributes.
Informally, an 'L-attributed' SDD is one where in the dependency-graph edges
can only go from left to right, but not from right to left.  An 'attribute
grammar' is an SDD without side effects.  An 'annotated parse tree' is a parse
tree showing the value(s) of its attribute(s).

A 'Syntax-directed translation scheme (SDT)' is a context free grammar
semantic actions (aka program fragments) embedded within production bodies.
Alternatively defined, an SDT is a complementary notation to SDD.  A 'postfix
SDT' is one with all actions at the right end of the production bodies (and
also an underlying S-attributed SDD, or is that implicit?).

Ordering the evaluation of attributes in general: create a dependency graph
from the annotated parse tree, do a topological sort, evaluate attributes in
that order.  When an SDD is S-attributed, we can omit the topological sort and
just evaluate the attributes in any bottom-up order, the postorder traversal
being especially simple.  Specifically, postorder corresponds exactly to the
order in which an LR parser reduces a production body to its head.

Conversion from one type to another is said to be an 'implicit conversion'
(aka 'coercion') if it is done automatically by the compiler.  An 'explicit
conversions' (aka 'cast') is one where the programmer must write something to
cause the conversion.  'Widening conversions' preserve information.
'Narrowing conversions' can lose information.

_Activation_ is a synonym to procedure call.  The _activation tree_ is the
tree of activations that builds up over time, the +main+ method being the
root.  An activation is said to be _open_ (aka _live_) when it was called but
has not yet returned.  Procedure calls and returns are usually managed by a
run-time stack called the _control stack_.  Each live activation has an
_activation record_ (aka _frame_) on the control stack.

A program has _temporal locality_ if the memory locations it accesses are
likely to be accessed again within a short period of time.  A program has
_spatial locality_ if memory locations close to the accessed location are
likely to be accessed within a short period of time.

_Mutator_ is the user program modifying the collection of objects in the heap.
A language in which the type of any data component can be determined is said
to be _type safe_, either statically at compile time or dynamically at run
time, the later being called _dynamically typed_. A language which is not type
safe is said to be _unsafe_.  In unsafe languages, memory addresses can be
manipulated arbitrarily: arbitrary arithmetic operations can be applied to
pointers.  Thus such a program theoretically could refer to any location in
memory at any time.

A _short-pause garbage collector_ is one that .... _Incremental collection_:
Interleaves garbage collection with the mutation.  _Partial collection_: In
each `round', only collect a subset of the garbage.  _Conservative_:  A GC
must not collect objects that are not garbage, but it does not have to collect
all the garbage in each round.  _floating garbage_ is garbage left behind
after collection.

*Garbage collector related questions*: Doesn't the book confuse garbage
collector tasks with memory manager tasks?  The garbage collector shall only
be concerned with when to free an object.  How to implement allocation and
deallocation of an object is the memory managers tasks.


== Bison

+api.value.type+:: Define variable defining data type of semantic values.  See
also the deprecated +YYSTYPE+.


== Flex

+YY_DECL+, by default +int yylex()+, declares the scanning routine.  When
called it executes the user's code he put within ++%{ %}++ at the beginning of
the ``rules'' section of the flex input.  When called for the first time, it
executes +YY_USER_INIT+.  It scans from +yyin+ (global input file, by default
stdin). When it find more than one match, it takes the longest match, which
includes the `trailing part' of trailing context rules.  The match is made
available in +yytext+ (global char* by default) and +yyleng+ (global
int). +YY_USER_ACTION+ is executed.  The user provided action associated to
matched rule is executed.  That action typically ends in an return statement.
If no match is found, the `default rule' is executed and the `offending
character' is considered matched and copied to stdout.  The remaining input is
scanned for another match -- however as said, typically the user actions end
in an return statement.



== Other terminologies

=== Bison

token type:: Terminal symbol defined in the Bison grammar.  An enumeration
identifying different tokens.  +Parser::token_type+ alias
+Parser::token::yytokentype+.
token:: Has a token type and a semantic value.
semantic value:: See also token.  E.g. the value of an integral literal token,
or the string constituting the name of an identifier token.

token type name:: Bison's term for token name from lexer viewpoint, terminal
symbol from grammar viewpoint.
grouping:: Bison's term for nonterminal symbol.
semantic value:: Bison's term for attribute value of token ??? or is it attribute
semantic action:: Bison's term for semantic action.
Bison parser:: The program, being a parser, being the main output of Bison
(utility).
Bison parser implementation file:: The source code of a bison parser.
Generated by Bison (utility).
