= Working effectively with legacy code

- legacy code = code without (unit) tests (feathers).
- Basic dilelema with legacy code: We need to introduce tests. For that, we often need to do refactorings. But refactorings should only be done with tests in place.
- The initial refacrtorings to get tests in place must be low risk. For that purpose we're also willing to create little design sins.
- The goal is to get code under test. For that purpose, also little design sins are allowed. As soon as the test is there, we can use refactorings to clean up any design kludges.
- At least test newly added methods

Seam = A place where you can alter behavior in your program without editing in that place. Seam types
  * preprocessor seams: redefine foo
  * link seams: link another definition of foo
  * object seams (aka test double): replace real object by a test double object

- Make use of refactoring tools to minimize risk

- Sprout method/class: the new functionality is implemented completely separated in a new method or new class

